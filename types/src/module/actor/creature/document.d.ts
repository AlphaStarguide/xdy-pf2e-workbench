/// <reference types="jquery" />
import { ActorPF2e } from "@actor";
import { HitPointsSummary } from "@actor/base";
import { CreatureSource } from "@actor/data";
import { ModifierPF2e, StatisticModifier } from "@actor/modifiers";
import { SaveType } from "@actor/types";
import { ArmorPF2e, ItemPF2e, PhysicalItemPF2e } from "@item";
import { ItemType } from "@item/data";
import { ItemCarryType } from "@item/physical/data";
import { ActiveEffectPF2e } from "@module/active-effect";
import { Rarity } from "@module/data";
import { RuleElementSynthetics } from "@module/rules";
import { UserPF2e } from "@module/user";
import { TokenDocumentPF2e } from "@scene";
import { CheckRoll } from "@system/check";
import { DamageType } from "@system/damage/types";
import { RawPredicate } from "@system/predication";
import { Statistic } from "@system/statistic";
import { CreatureSkills, CreatureSpeeds, CreatureSystemData, LabeledSpeed, MovementType, SenseData, VisionLevel } from "./data";
import { CreatureSensePF2e } from "./sense";
import { Alignment, CreatureTrait, CreatureUpdateContext, GetReachParameters, IsFlatFootedParams } from "./types";
/** An "actor" in a Pathfinder sense rather than a Foundry one: all should contain attributes and abilities */
declare abstract class CreaturePF2e<TParent extends TokenDocumentPF2e | null = TokenDocumentPF2e | null> extends ActorPF2e<TParent> {
    protected _skills: CreatureSkills | null;
    /** Skill `Statistic`s for the creature */
    get skills(): CreatureSkills;
    /** The creature's position on the alignment axes */
    get alignment(): Alignment;
    get rarity(): Rarity;
    get allowedItemTypes(): (ItemType | "physical")[];
    /**
     * A currently naive measurement of this creature's reach
     * @param [context.action] The action context of the reach measurement. Interact actions don't consider weapons.
     * @param [context.weapon] The "weapon," literal or otherwise, used in an attack-reach measurement
     */
    getReach({ action, weapon }?: GetReachParameters): number;
    get visionLevel(): VisionLevel;
    get hasDarkvision(): boolean;
    get hasLowLightVision(): boolean;
    get canSee(): boolean;
    get canAct(): boolean;
    get canAttack(): boolean;
    get isDead(): boolean;
    /** Whether the creature emits sound: overridable by AE-like */
    get emitsSound(): boolean;
    get isSpellcaster(): boolean;
    get perception(): Statistic;
    get wornArmor(): ArmorPF2e<this> | null;
    /** Get the held shield of most use to the wielder */
    get heldShield(): ArmorPF2e<this> | null;
    /** Whether the actor is flat-footed in the current scene context: currently only handles flanking */
    isFlatFooted({ dueTo }: IsFlatFootedParams): boolean;
    /** Setup base ephemeral data to be modified by active effects and derived-data preparation */
    prepareBaseData(): void;
    prepareEmbeddedDocuments(): void;
    prepareDerivedData(): void;
    protected prepareInitiative(): void;
    protected prepareSynthetics(): void;
    /** Add a circumstance bonus if this creature has a raised shield */
    protected getShieldBonus(): ModifierPF2e | null;
    /**
     * Changes the carry type of an item (held/worn/stowed/etc) and/or regrips/reslots
     * @param item       The item
     * @param carryType  Location to be set to
     * @param handsHeld  Number of hands being held
     * @param inSlot     Whether the item is in the slot or not. Equivilent to "equipped" previously
     */
    adjustCarryType(item: PhysicalItemPF2e<CreaturePF2e>, carryType: ItemCarryType, handsHeld?: number, inSlot?: boolean): Promise<void>;
    /**
     * Adds a custom modifier that will be included when determining the final value of a stat. The slug generated by
     * the name parameter must be unique for the custom modifiers for the specified stat, or it will be ignored.
     */
    addCustomModifier(stat: string, label: string, value: number, type: string, predicate?: RawPredicate, damageType?: DamageType, damageCategory?: string): Promise<void>;
    /** Removes a custom modifier by slug */
    removeCustomModifier(stat: string, slug: string): Promise<void>;
    /**
     * Roll a Recovery Check
     * Prompt the user for input regarding Advantage/Disadvantage and any Situational Bonus
     */
    rollRecovery(event: JQuery.TriggeredEvent): Promise<Rolled<CheckRoll> | null>;
    /** Prepare derived creature senses from Rules Element synthetics */
    prepareSenses(data: SenseData[], synthetics: RuleElementSynthetics): CreatureSensePF2e[];
    prepareSpeed(movementType: "land"): this["system"]["attributes"]["speed"];
    prepareSpeed(movementType: Exclude<MovementType, "land">): (LabeledSpeed & StatisticModifier) | null;
    prepareSpeed(movementType: MovementType): CreatureSpeeds | (LabeledSpeed & StatisticModifier) | null;
    protected _preUpdate(changed: DeepPartial<this["_source"]>, options: CreatureUpdateContext<TParent>, user: UserPF2e): Promise<void>;
}
interface CreaturePF2e<TParent extends TokenDocumentPF2e | null = TokenDocumentPF2e | null> extends ActorPF2e<TParent> {
    readonly _source: CreatureSource;
    system: CreatureSystemData;
    /** Saving throw rolls for the creature, built during data prep */
    saves: Record<SaveType, Statistic>;
    get traits(): Set<CreatureTrait>;
    get hitPoints(): HitPointsSummary;
    /** Expand DocumentModificationContext for creatures */
    update(data: DocumentUpdateData<this>, options?: CreatureUpdateContext<TParent>): Promise<this>;
    /** See implementation in class */
    updateEmbeddedDocuments(embeddedName: "ActiveEffect", updateData: EmbeddedDocumentUpdateData<ActiveEffectPF2e<this>>[], options?: DocumentUpdateContext<this>): Promise<ActiveEffectPF2e<this>[]>;
    updateEmbeddedDocuments(embeddedName: "Item", updateData: EmbeddedDocumentUpdateData<ItemPF2e<this>>[], options?: DocumentUpdateContext<this>): Promise<ItemPF2e<this>[]>;
    updateEmbeddedDocuments(embeddedName: "ActiveEffect" | "Item", updateData: EmbeddedDocumentUpdateData<ActiveEffectPF2e<this> | ItemPF2e<this>>[], options?: DocumentUpdateContext<this>): Promise<ActiveEffectPF2e<this>[] | ItemPF2e<this>[]>;
    deleteEmbeddedDocuments(embeddedName: "ActiveEffect", ids: string[], context?: DocumentModificationContext<this>): Promise<CollectionValue<this["effects"]>[]>;
    deleteEmbeddedDocuments(embeddedName: "Item", ids: string[], context?: DocumentModificationContext<this>): Promise<CollectionValue<this["items"]>[]>;
    deleteEmbeddedDocuments(embeddedName: "ActiveEffect" | "Item", ids: string[], context?: DocumentModificationContext<this>): Promise<CollectionValue<this["effects"]>[] | CollectionValue<this["items"]>[]>;
}
export { CreaturePF2e };
